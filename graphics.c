#include "graphics.h"
#include "gba.h"
#include <stdlib.h>
#include "logic.h"
#include "images/frogger.h"
#include "images/regcar.h"
#include "images/regcarop.h"
#include "images/Small.h"
#include "images/SmallRev.h"
#include "images/RegRev2.h"
#include "images/wave.h"
// TA-TODO: Include any header files for images generated by nin10kit.
// Example for the provided garbage image:
//#include "images/garbage.h"

// TA-TODO: Add any draw/undraw functions for sub-elements of your app here.
// For example, for a snake game, you could have a drawSnake function
// or a drawFood function
//
// e.g.:
// static void drawSnake(Snake* snake);
// static void drawFood(Food* food);

// This function will be used to draw everything about the app
// including the background and whatnot.


//rect *car[10] = malloc(sizeof(rect)*10); 
rect *level4_cars[15];
int capacity = 15;
rect *level2_cars[15];
rect *level3_cars[15];
rect *level1_cars[15];
rect *level5_cars[15];
rect frogger = {(int)(WIDTH/2), HEIGHT - PADDING-CAR_WIDTH, CAR_WIDTH, CAR_WIDTH, img, 2};
//LEVEL1
rect a1 = {0, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};
rect b1 = {2*REG_CAR_LENGTH, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};
rect c1 = {4*REG_CAR_LENGTH, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};
rect d1 = {6*REG_CAR_LENGTH, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};
rect e1 = {8*REG_CAR_LENGTH, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};
rect f1 = {10*REG_CAR_LENGTH, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};
rect g1 = {12*REG_CAR_LENGTH, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};
rect h1 = {14*REG_CAR_LENGTH, lvl1, REG_CAR_LENGTH, CAR_WIDTH, RegCar, REG_SPEED};


//LEVEL2
rect a2 = {0, lvl2, SEMI_LENGTH, CAR_WIDTH, RegCar, SEMI_SPEED};
rect b2 = {SEMI_LENGTH*2, lvl2, SEMI_LENGTH, CAR_WIDTH, RegCar, SEMI_SPEED};
rect c2 = {SEMI_LENGTH*4, lvl2, SEMI_LENGTH, CAR_WIDTH, RegCar, SEMI_SPEED};
rect d2 = {SEMI_LENGTH*6, lvl2, SEMI_LENGTH, CAR_WIDTH, RegCar, SEMI_SPEED};
rect e2 = {SEMI_LENGTH*-2, lvl2, SEMI_LENGTH, CAR_WIDTH, RegCar, SEMI_SPEED};

//LEVEL3
rect a3 = {0, lvl3, SMALL_CAR_LENGTH, CAR_WIDTH, Small, SMALL_CAR_SPEED};
rect b3 = {4*SMALL_CAR_LENGTH, lvl3, SMALL_CAR_LENGTH, CAR_WIDTH, 	Small, SMALL_CAR_SPEED};
rect c3 = {8*SMALL_CAR_LENGTH, lvl3, SMALL_CAR_LENGTH, CAR_WIDTH, 	Small, SMALL_CAR_SPEED};
rect d3 = {9*SMALL_CAR_LENGTH, lvl3, SMALL_CAR_LENGTH, CAR_WIDTH, 	Small, SMALL_CAR_SPEED};

//LEVEL4
rect a4 = {0, lvl4, REG_CAR_LENGTH, CAR_WIDTH, RegCarOp, -REG_SPEED};
rect b4 = {2*REG_CAR_LENGTH, lvl4, REG_CAR_LENGTH, CAR_WIDTH, RegCarOp, -REG_SPEED};
rect c4 = { 6* REG_CAR_LENGTH, lvl4, REG_CAR_LENGTH, CAR_WIDTH, RegCarOp, -REG_SPEED};
rect d4 = {12*REG_CAR_LENGTH, lvl4, REG_CAR_LENGTH, CAR_WIDTH, RegCarOp, -REG_SPEED};

rect a5 = {0, lvl5, SMALL_CAR_LENGTH, CAR_WIDTH, SmallRev, -1};
rect b5 = {4*SMALL_CAR_LENGTH, lvl5, SMALL_CAR_LENGTH, CAR_WIDTH, 	SmallRev, -1};
rect c5 = {8*SMALL_CAR_LENGTH, HEIGHT-15, REG_CAR_LENGTH, CAR_WIDTH, 	Rev2, -2};
rect d5 = {9*SMALL_CAR_LENGTH, lvl5, SMALL_CAR_LENGTH, CAR_WIDTH, 	SmallRev, -1};

rect wv = {180, lvl2, WAVE_WIDTH, WAVE_HEIGHT, wave, 1};


void frogger_move(int move){
	if(move == BUTTON_UP){
		frogger.y -= frogger.speed;
		drawImageDMA(frogger.x, frogger.y, frogger.sizex, frogger.sizey, frogger.img);
		drawImageDMA(frogger.x, frogger.y + frogger.sizey, frogger.sizex, frogger.speed, BLACK);

	} else if(move == BUTTON_RIGHT &&  frogger.x < WIDTH - 2*PADDING){
		frogger.x += frogger.speed;
		drawImageDMA(frogger.x, frogger.y, frogger.sizex, frogger.sizey, img);
		drawImageDMA(frogger.x - (frogger.speed+1), frogger.y , frogger.speed+1, frogger.sizey, BLACK);

	}else if(move == BUTTON_LEFT && frogger.x > PADDING ){
		frogger.x -= frogger.speed;
		drawImageDMA(frogger.x, frogger.y, frogger.sizex, frogger.sizey, img);
		drawImageDMA(frogger.x  + frogger.sizex, frogger.y , frogger.speed+1, frogger.sizey, BLACK);

	}else if(move == BUTTON_DOWN && frogger.y < HEIGHT - 2*PADDING){
		frogger.y += frogger.speed;
		drawImageDMA(frogger.x, frogger.y, frogger.sizex, frogger.sizey, img);
		drawImageDMA(frogger.x, frogger.y - frogger.speed, frogger.sizex, frogger.speed, BLACK);

	}
}
void init(void){

	//TODO: get it to add rects to the list and prot them out. currently doesnt	
	level1_cars[0] = &a1;
	level1_cars[1] = &b1;
	level1_cars[2] = &c1;
	level1_cars[3] = &d1;
	level1_cars[4] = &e1;
	level1_cars[5] = &f1;
	level1_cars[6] = &g1;
	level1_cars[7] = &h1;
	

	level4_cars[0] = &b4;
	level4_cars[1] = &a4;
	level4_cars[2] = &c4;
	//level4_cars[3] = &d4;

	level2_cars[1] = &a2;
	level2_cars[5] = &b2;
	level2_cars[8] = &c2;
	level2_cars[9] = &d2;
	level2_cars[10] = &e2;

	level3_cars[0] = &a3;
	level3_cars[1] = &b3;
	level3_cars[2] = &c3;



	//level5_cars[0] = &a5;
	//level5_cars[1] = &b5;
	level5_cars[2] = &c5;
	//level5_cars[3] = &d5;
	//level1_cars[0] = &a1;
	//capacity = 1;

	//*car[4] = (rect){1, 70, REG_CAR_LENGTH, CAR_WIDTH, YELLOW, REG_SPEED};
	
	capacity = 11;
	
	//capacity = 5;

}
static void rectMove(int speed, rect* rect){
	if(rect != NULL){
		drawImageDMA(rect -> x, rect -> y, rect -> sizex, rect -> sizey, rect -> img);
		rect -> x += speed;
		if(rect -> x <= 0){
			//drawRectDMA(rect -> x, rect -> y - 2, rect -> sizex, 3, BLACK);
		}
		if(rect -> x >= WIDTH || rect -> x <= 0){
			if(rect -> x > 0){
				rect -> x = 0;
			} 
			else{
				rect -> x = WIDTH-1;
			}
		}
	}
	
}


static void moveWave(int speed, rect* rect){
	if(rect != NULL){
		if(40 - rect -> x <= rect -> sizex && 40 - rect -> x > 0){
			resizeImage(rect -> x, rect -> y, 40 - rect -> x, WAVE_WIDTH, WAVE_HEIGHT, rect -> img);
		} else if(rect -> x > 40+4*CAR_WIDTH || rect -> x < 40){
			drawImageDMA(rect -> x, rect -> y, rect -> sizex, rect -> sizey, rect -> img);

		}
		rect -> x += speed;
		if(rect -> x >= WIDTH || rect -> x <= 0){
			if(rect -> x > 0){
				rect -> x = 0;
			} 
			else{
				rect -> x = WIDTH-1;
			}
		}
	}
	
}
static void eraseRect(int speed, rect* rect){
	if(speed > 0){
		if(1 == 1){
			drawRectDMA(WIDTH - PADDING, rect -> y - 1, PADDING, rect -> sizey+1, BLACK);
			drawRectDMA(0, rect -> y - 1, PADDING, rect -> sizey+5, BLACK);
		}
		drawRectDMA(rect -> x - speed, rect -> y - 1, abs(speed), rect -> sizey+1, BLACK);
	}
	else{
		if(1 == 1){
			drawRectDMA(WIDTH - PADDING, rect -> y - 1, PADDING, rect -> sizey+1, BLACK);
			drawRectDMA(0, rect -> y - 1, PADDING, rect -> sizey+5, BLACK);
		}
		drawRectDMA(rect -> x + abs(speed)+ rect -> sizex, rect -> y - 3, abs(speed)+2, rect -> sizey+4, BLACK);
	}

}

static void eraseWave(int speed, rect* rect){
	if(rect -> x > 40+4*CAR_WIDTH || rect -> x <= 40){
		if(speed > 0){
			if(1 == 1){
				drawRectDMA(WIDTH - PADDING, rect -> y-1, PADDING, rect -> sizey+3, BLACK);
				drawRectDMA(0, rect -> y, PADDING, rect -> sizey+5, BLACK);
				//drawRectDMA(PADDING, rect -> y + rect -> sizey, WIDTH-2*PADDING, 1, BLACK);
				drawRectDMA(PADDING, rect -> y + rect -> sizey, 40-PADDING, 2, BLUE);
                drawRectDMA(PADDING+40 + 4*CAR_WIDTH, rect -> y + rect -> sizey, WIDTH - (2*PADDING)-(40+2*CAR_WIDTH), 2, BLUE);

			}
			if(rect -> x < WIDTH - PADDING + 1 && rect -> x > PADDING)
				drawRectDMA(rect -> x - speed, rect -> y, abs(speed), rect -> sizey + 1, BLUE);
		} else{
			if(1 == 1){
				drawRectDMA(WIDTH - PADDING, rect -> y, PADDING, rect -> sizey+1, BLACK);
				drawRectDMA(0, rect -> y, PADDING, rect -> sizey+5, BLACK);
				drawRectDMA(PADDING, rect -> y + rect -> sizey, WIDTH-2*PADDING, 1, BLUE);
			}
			if(rect -> x <= PADDING)
				drawRectDMA(PADDING, rect -> y, rect -> sizex, rect -> sizey, BLUE);
			drawRectDMA(rect -> x + rect -> sizex, rect -> y , abs(speed), rect -> sizey+1, RED);
		}
	}

	
}

void fullDrawAppState(GBAState *state) {
	//rectMove(INCREMENT, &a1);
    //rectMove(INCREMENT, &a2);
    //rectMove(-(INCREMENT+2), &a3);
    //drawRectDMA(car[5] -> x, 70, REG_CAR_LENGTH, CAR_WIDTH, MAGENTA);
    //drawRectDMA(car[4] -> x, car[4] -> y, REG_CAR_LENGTH, CAR_WIDTH, MAGENTA);

	    for(int i = 0; i< capacity; i++){
	    	rectMove(level4_cars[i] -> speed, level4_cars[i]);
	    }
	     for(int i = 0; i< capacity; i++){
	    	rectMove(level1_cars[i] -> speed, level1_cars[i]);
	    }
	    for(int i = 0; i< capacity; i++){
	    	rectMove(level3_cars[i] -> speed, level3_cars[i]);
	    }
	       
	 	moveWave(1, &wv);
    

  	
    //drawRectDMA(PADDING, HEIGHT/2, WIDTH-2*PADDING, CAR_WIDTH, BLUE );
    // TA-TODO: IMPLEMENT.
    UNUSED(state);
}

// This function will be used to undraw (i.e. erase) things that might
// move in a frame. E.g. in a Snake game, erase the Snake, the food & the score.
void undrawAppState(AppState *state) {
	
	 for(int i = 0; i< capacity; i++){
    	eraseRect(level4_cars[i] -> speed, level4_cars[i]);
    }
     for(int i = 0; i< capacity; i++){
    	eraseRect(level1_cars[i] -> speed, level1_cars[i]);
    }
     for(int i = 0; i< capacity; i++){
    	eraseRect(level3_cars[i] -> speed, level3_cars[i]);
    }
   
   eraseWave(1, &wv);

	//er
	//eraseRect(&a1, INCREMENT);
	//eraseRect(&a2, INCREMENT);, 
	//eraseRect(&a3, -(INCREMENT + 2));
    // TA-TODO: IMPLEMENT.
    UNUSED(state);
}

// This function will be used to draw things that might have moved in a frame.
// For example, in a Snake game, draw the snake, the food, the score.
void drawAppState(AppState *state) {
    // TA-TODO: IMPLEMENT.

    UNUSED(state);
}


